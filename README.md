# machinelearning
import numpy as np class Perceptron(object):     """     eta:学习率     n_iter:权重向量的训练次数     w：神经分叉权重向量     errors_:用于记录神经元判断出错的次数     """     def  __init__(self, eta = 0.01,n_iter=10):         self.eta = eta;         self.n_iter = n_iter         pass     def fit(self,X,y):         """         输入训练数据，培训神经元x输入样本量，y对应样本量         A：shape[n_sample,n_features]         X:[[1,2,3].[4,5,6]]         n_samples:2         n_features:3         y:[1,-1]         """         """         初始化权重向量为0         加一是因为前面的算法提到的w0，也就是不掉函数阈值         """         self.w_ = np.zero(1+X.shape[1]);         self.errors = []                  for _ in range(self.n_iter):             errors = 0             """             X:[[1,2,3].[4,5,6]]             y:[1,-1]             zip(X,y) = [[1,2,3, 1],[4,5,6, -1]]             """             for xi,target in zip(X,y):                 update = self.eta * (target - sel.predict(xi))                 self.w_[1:] += update * xi                 self.w_[0] == update;                 errors += int(update !=0.0)                 self.errors_.qppend(errors)                 pass                          pass         def net_input(self, x):             return np.dot(X,self.w)[1:] + self.w[0]             pass                  def predict(self, x):             return np.where[self.net_input(x) >= 0.0 : 1, -1]             pass         pass
